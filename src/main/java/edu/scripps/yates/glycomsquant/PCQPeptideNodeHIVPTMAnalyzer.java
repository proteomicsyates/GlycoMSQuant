package edu.scripps.yates.glycomsquant;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import edu.scripps.yates.census.read.model.interfaces.QuantifiedPSMInterface;
import edu.scripps.yates.pcq.model.PCQPeptideNode;
import edu.scripps.yates.pcq.model.PCQProteinNode;
import edu.scripps.yates.utilities.proteomicsmodel.Ratio;
import edu.scripps.yates.utilities.sequence.PTMInProtein;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntObjectHashMap;

/**
 * Analyzes the {@link PCQPeptideNode} generated by PCQ
 * 
 * @author salvador
 *
 */
public class PCQPeptideNodeHIVPTMAnalyzer {

	private final List<PCQPeptideNode> peptideNodes;
//	private final static 

	public PCQPeptideNodeHIVPTMAnalyzer(List<PCQPeptideNode> peptideNodes) {
		this.peptideNodes = peptideNodes;
	}

	public List<HIVPosition> getHIVPositions(String proteinAcc) {
		// filter by protein
		List<PCQPeptideNode> peptideNodesFiltered = peptideNodes.stream()
				.filter(p -> containsProtein(p.getProteinNodes(), proteinAcc)).collect(Collectors.toList());
		// create HIVPosition objects
		TIntObjectMap<HIVPosition> map = new TIntObjectHashMap<HIVPosition>();
		for (PCQPeptideNode peptideNode : peptideNodesFiltered) {
			String peptideKey = peptideNode.getKey();

			List<PTMInProtein> positionsInProtein = getPositionsInProtein(peptideKey);
			for (PTMInProtein positionInProtein : positionsInProtein) {
				if (!positionInProtein.getProteinACC().equals(proteinAcc)) {
					continue;
				}
				int position = positionInProtein.getPosition();
				String ptmCode = String.valueOf(positionInProtein.getDeltaMass());
				PTMCode ptmCodeObj = PTMCode.getByValue(ptmCode);
				if (position == 109 && ptmCodeObj == PTMCode._0) {

					Set<QuantifiedPSMInterface> psms = peptideNode.getQuantifiedPSMs();
					for (QuantifiedPSMInterface psm : psms) {
						double ratio = psm.getQuantRatios().iterator().next().getValue();
					}

				}
				if (!map.containsKey(position)) {
					map.put(position, new HIVPosition(position));
				}

				Set<QuantifiedPSMInterface> psms = peptideNode.getQuantifiedPSMs();
				for (QuantifiedPSMInterface psm : psms) {

					Set<Ratio> ratios = psm.getRatios();
					Ratio ratio = ratios.iterator().next();
					double value = ratio.getValue();
					// if the ratio is 0.0, it is because it was not present
					if (Double.compare(0.0, value) != 0) {
						map.get(position).addValue(ptmCodeObj, value, psm);
					}
				}

			}
		}

		List<HIVPosition> ret = new ArrayList<HIVPosition>();
		ret.addAll(map.valueCollection());
		// sort by position
		Collections.sort(ret, new Comparator<HIVPosition>() {

			@Override
			public int compare(HIVPosition o1, HIVPosition o2) {
				return Integer.compare(o1.getPosition(), o2.getPosition());
			}
		});
		return ret;
	}

	private List<PTMInProtein> getPositionsInProtein(String peptideKey) {
		Pattern pattern = Pattern.compile("(\\w)(\\d+)\\(\\+(.*)\\)");
		List<PTMInProtein> ret = new ArrayList<PTMInProtein>();
		if (peptideKey.contains("#")) {
			String[] splitPeptideKey = peptideKey.split("#");

			for (int i = 1; i < splitPeptideKey.length; i++) {
				String individualPosition = splitPeptideKey[i];
				Matcher matcher = pattern.matcher(individualPosition);
				if (matcher.find()) {
					int position = Integer.valueOf(matcher.group(2));
					char aa = matcher.group(1).charAt(0);
					String proteinACC = splitPeptideKey[0];
					double deltaMass = Double.valueOf(matcher.group(3));
					PTMInProtein ptm = new PTMInProtein(position, aa, proteinACC, deltaMass);
					ret.add(ptm);
				}
			}
		}
		return ret;
	}

	private boolean containsProtein(Set<PCQProteinNode> proteinNodes, String proteinAcc) {
		for (PCQProteinNode pcqProteinNode : proteinNodes) {
			if (pcqProteinNode.getAccessionString().contains(proteinAcc)) {
				return true;
			}
		}
		return false;
	}
}
